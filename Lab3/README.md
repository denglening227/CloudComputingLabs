# Lab3: 简易的分布式KV库

   **⚠  DDL：2020年5月27日 上午10点整 初级版+高级版**

   **⚠  DDL：2020年6月03日 上午10点整 极限版+终极版**

* 在本地 CloudComputingLabs 文件夹使用 `git pull` 指令从实验仓库中获取最近提交。
* 实验指导书为 `Lab3/README English.ver.md` ，本文档其翻译版本。
* 所有材料置于 `Lab3/` 文件夹内。


## 1. Overview 概述

* 自行实现一个简易【Distributed 分布式的】【In-memory 数据存于内存的】【Key-Value 键-值存储的】数据库。
* 实现中可以使用二阶段提交（*Two*-*phase Commit*）协议，以保证键-值存储的并发性与鲁棒性（Robustness）。

### Goals 目标

* 了解 创建并发系统过程中遇到的问题与困难。
* 了解 如何通过一个简易协议来保证多并发服务器的并发性。
* 使用一些简单方案来处理服务器故障。



## 2. Background 背景

### 2.1 KV store 键-值存储数据库

#### Features 特点

一个【数据存于内存】【键-值存储】的数据库（本文档简称：**KV库**）有如下特点：

* In-Memory Database 内存数据库 | 将内容存放在内存中，而非传统存放在外部存储器中（实操中，KV库服务器常仅把【数据存于主内存】用以满足大部分用户，同时将数据备份到硬盘内以确保持久性。但**本次实验不要求数据保持持久性。**）

* Key-Value Store 键-值存储 | 使用「键-值」的数据结构，如下表：

  ```
  |-------|-----------------------|
  | Key	|	Value		|
  |-------|-----------------------|
  | K1	|	AAA,BBB,CCC	|
  | K2	|	AAA,BBB 	|
  |-------|-----------------------|
  ```

#### Commands 用户操作指令

通常，KV存储给用户提供了以下方法从数据库内**【存/删/读】**数据：

* **`set(key,value)`** 存储。两参数对应上表 key、value。（一些KV库把此命名为 **put**）
* **`del(key)`** 删除。参数对应上表 key，以此定位。
* **`value=get(key)`** 读取。参数对应上表 key，以此定位，返回 value 值。

### 2.2 Distributed KV Store 分布式KV库

在大型云服务中，为了性能和鲁棒性，通常以分布式方式构建KV库。

例如，KV库可将其数据分布在多台服务器中，并同时使用这些服务器来满足用户请求。

* 负载高时，用户请求可以平均地平衡到多个服务器
* 数据库可以从某些服务器的故障中幸存下来。

#### Problems 存在问题

分布式KV库中，**一致性问题**最为棘手。例如，

* 假设一KV库有两个服务器 A、B，用以保存数据并服务于用户请求。
* 用户 1 在服务器 A 保存了密钥。
* 短时间内，用户 2,3 请求获取该密钥，如何确保他们获取到的密钥是最新值？
* 更具挑战性的是，用户递交请求时，服务器和网络可能致使请求失败。
* 下一要点将介绍一个简易但经典的、可保障分布式数据库服务器之一致性的协议——

### 2.3 Two-phase commit 二阶段提交

此为简短介绍，鼓励自行广搜索材料。如：[这](https://www.bilibili.com/video/BV1at411y7iQ)是一个介绍 2PC 的视频。现将描述共识里最简单但有效的协议——**二阶段提交 / 2PC**。

* 在数据库分布在多个分布式服务器时，该协议仍能保证一致性，即多个服务器同意/不同意【原子地】执行某项操作。

* **大致架构**

  1. 首先，2PC 在每个服务器都存有**提交日志（Commit Log）**，以保证回溯。日志常被用于确保所有计算机全部提交（Commit）或不提交事务。
  2. 其次，存在一个**总协调员（Global Coordinator）**角色。它从客户端接收到*事务信息（如 set/delete/get）*并返信客户端以结果，同时协调多个数据库服务器，以确保全部提交/中止事务。

* 基于以上架构，2PC 的运行分为**两个阶段**：

  1. **【第一阶段：准备阶段】**

     * 总协调员发出请求，让所有服务器（参与者）做出承诺：会记录或回滚事务。
     * 参与者记录该承诺到日志中，并告知协调员已收到。
     * 若有其一决定中止事务，协调员会把「Abort（中止）」写入其日志。
     * 然后协调员会广而告之，让每个参与者均中止事务，并把「Abort」写入日志。

  2. **【第二阶段：提交或中止阶段】**

     * 所有参与者发信已准备好后，协调员将「Commit」请求写入它们的日志。
     * 接着协调员请求所有参与者作出提交（Commit）。
     * 所有参与者返信以 ACK。
     * 协调员接收到 ACKs 后，会把「Got Commit」写入日志。

     ![two-phase-commit](images/two-phase-commit.png)

* **详细步骤遵循以下：**

  1. ***【第一阶段：准备阶段】***
     * 拟提交（Commit）事务，协调员始发信 **REQUEST-TO-PREPARE（请求准备）** 给每个参与者。
     * 协调员等待所有参与者对该请求 **“vote”（投票）**。
     * 每个参与者返信给协调员，以作上述请求之回复，如下：
       * 参与者若准备好提交，投 **PREPARED（已准备）**票。
       * 参与者若以任意理由投 **NO（拒绝）**票，通常是由于本地错误导致无法准备事务。
       * 参与者可能无限期延迟投票，例如出于网络致使投票信息丢失。
  2. ***【第二阶段：提交或中止阶段】***
     * 协调员若从全员处收信以 **RREPARED（已准备）**，则决定提交（commit）。事务将会正式提交。
     * 协调员若从某一参与者处收信以 **NO（拒绝）**，则决定中止（abort）。事务将会中止。
     * 协调员会向全员发信它的最终决定：**COMMIT** 或 **ABORT**。
     * 参与者全员返信 **DONE** 以作回应 ACK。
     * 协调员收到全员 **DONE** 信息后，可以回复事务处理结果给客户端（无论成败），并且 *forget（遗忘）*该事务。这表示，用于追踪事务相关信息的内存将被释放。



## 3. Your Lab Task 实验任务

### 3.1 Task overview 任务概览

![KVStoreOverview](images/KVStoreOverview.jpg)

* 实现一个简单的**【分布式KV库】**。
* 该库作为网络服务在远程计算机上运行。
* 该远程计算机可以接收客户端发送的在库操作（存/删/读），并通过网络返信结果。
* 为应对故障，KV库要在多台计算机分布，并通过网络相互连接。
* 使用 2PC 协议，以维护多计算机之间的数据库一致性。
* 为简化任务，KV库之数据、2PC 协议之日志仅存于主存储器。

* 详情如下：

### 3.2 KV store command formats 命令格式

* 该库仅需三条命令如下：（区分大小写）
  * **`set(key,value)`**  两参数对应上表 key、value。（一些KV库把此命名为 **put**）
  * **`del(key)`**  参数对应上表 key，以此定位。
  * **`value=get(key)`**  参数对应上表 key，以此定位，返回 value 值。

* 该命令（包括自变量）和返回结果需使用消息格式封装到网络报文中。

* 为简化任务，所有键和值都作为字符串存储在库中。

* 进一步细节如下：

  #### 3.2.1 Network message format 网络报文格式

  本实验需使用 **RESP(REdis Serialization Protocol) 之简化版本** 的报文格式，来传递KV库的命令（名为「请求报文」）以及返回结果（名为「响应报文」）。详情如下：

  ##### 3.2.1.1 Client request message 客户端的请求报文

  通过 **RESP Arrays** (更多请看`section 3.2.2`)。该阵列之组成为：

  * 始以一个星号 **`*`** 字符字节，随以该阵列的多个十进制数字化元素，尾以 CRLF。
  * 任意数量的大块字符串（最大长度 512MB）。字符串组成如下：
    * 始以美元 **`$`** 字符字节，随以字符串之字节数（一个前缀示长度），尾以 CRLF。
    * 实际字符串的数据。
    * 终以 CRLF，即 `\r\n`。

  【例】字符串 `CS06142` 编码后：`$7\r\nCS06142\r\n`

  该字符串始以美元 **`$`** 字符，随以数字 `7` 以述 `CS06142` 之长为为 7，最后终以 CRLF。然后跟上实际字符串数据 `CS06142` 以及阵列之结尾 CRLF 。

  ##### 3.2.1.2 Server response message 服务器的响应报文

  1)&ensp;Success message 成功报文，其编码方式如下：

  * 始以加号 **`+`** 字符，随以一个不包含 CR/LF 字符的字符串（不许换行），终以 CRLF。

  【例】`+OK\r\n` | 指令 `SET` 得到「OK」之回信，表示成功。（详见 `section 3.2.2`）

  2)&ensp;Error message 出错报文：

  * 始以减号 **`-`** 字符，随以一个不包含 CR/LF 字符的字符串（不许换行），终以 CRLF。

  【例】`-ERROR\r\n` | 有任意错误发生，就返回该信息。（详见 `section 3.2.2`）

  3)&ensp;RESP Arrays message RESP阵列报文：

  【例】`*2\r\n$5\r\nCloud\r\n$9\r\nComputing\r\n`  |  指令 `GET` 实行成功，就返回该信息。（详见 `section 3.2.2`）

  4)&ensp;Integer message 整数报文：

  * 始以冒号 **`:`** 字符，随以一个有意指的数字（不许换行），终以 CRLF。

  【例】 `:1\r\n` | 一些命令需要返回整数（如指令 `DEL`，详见 `section 3.2.2`）

  ### 3.2.2 Database commands 库命令（由客户端输入）

  ##### 3.2.2.1 SET command 存储指令

  `SET key value` 设置键值。若某键已存在一个值，则覆盖。

  【例】设置键 `CS06142` 对应值为 `Cloud Computing`，则输入命令：

  * `SET CS06142 "Cloud Computing"`

  * 根据 `section 3.2.1` 内容，该命令会被编码为：

  `*4\r\n$3\r\nSET\r\n$7\r\nCS06142\r\n$5\r\nCloud\r\n$9\r\nComputing\r\n`

  【注意】编码后的报文始以星号 **`*`** 字符字节，随以4个批量字符串如下，尾以 CRLF。

  * `$3\r\nSET\r\n` `$7\r\nCS06142\r\n` `$5\r\nCloud\r\n` `$9\r\nComputing\r\n`. 

  * 若 `SET` 执行成功，返回：`+OK\r\n`。
  * 若执行失败发生错误，返回：`-ERROR\r\n`。

  ##### 3.2.2.2 GET command 读取指令

  `GET key` 读取该键所对应的值。若无值，则返回 `nil`。

  【例】检查键 `CS06142` 的值，则输入命令：`GET CS06142`。被编码后如下：

  * `*2\r\n$3\r\nGET\r\n$7\r\nCS06142\r\n`

  * 若执行成功，返回：`*1\r\n$3\r\nnil\r\n`
  * 若发生错误，返回：`-ERROR\r\n`

  ##### 3.2.2.3 DEL command 删除指令

  `DEL key1 key2 ...` 该指令用于删除一或多个指定的键（任意数字，报文最大长度 512MB）。若键不存在，则忽略。不论成败，返回已删除键的数量。

  【例】删除键 `CS06142` 和 `CS162`，则输入命令：`DEL CS06142 CS162`。编码后如下：

  * `*3\r\n$3\r\nDEL\r\n$7\r\nCS06142\r\n$5\r\nCS162\r\n`
  * 若成功执行，返回：`:1\r\n`
  * 若发生错误，返回：`-ERROR\r\n`

  【注意】此处由于上述只设置了前者的值而能删除成功，后者不存在值则忽略。因此，数字为 1。

### 3.3 Use 2PC protocol to build a KV store on multiple servers 使用2PC协议构建一个分布于多服务器上的KV库

* 实现一个**协调员程序**。
  * 该程序不存储任何数据。
  * 该程序仅用于接收客户端命令、运行2PC协调参与者以一致执行命令、返信客户端。
* 实现一个**参与者程序**。
  * 该程序需在其主存储器终维护一个KV数据库。
  * 该程序需执行从协调员程序获取的命令，并将结果返信协调员。
* 协调员与参与者之间的通信消息格式：任意格式。例如，前述之 RESP 格式，或其它一些 RPC 库（RPC Library）。

### 3.4 Run your program 运行程序

#### 3.4.1 Program arguments 程序参数

* 启用长选项（Long Options）接收程序参数，就像 Lab2 一样。
* 仅有一个程序参数：`--config_path` 以指定配置文件的路径。
* 所有详细配置均写入配置文件中。
* 程序应可以解析配置文件，并以协调员或参与者身份运行。

**【例】**假设程序名为 `kvstore2pcsystem`

* 运行协调员进程：
* `./kvstore2pcsystem --config_path ./src/coordinator.conf`
* 运行参与者进程：
* `./kvstore2pcsystem --config_path ./src/participant.conf`
* 键入以上命令后，程序应正确运行，不需要任何其它输入。

#### 3.4.2 Configuration file format 配置文件格式

配置文件由以下两种行（two kinds of lines）组成：

* **A comment line 注释行**
  * 始以感叹 `!` 字符。
  * 程序将不会再解析这一行。
* **A parameter line 参数行**
  * 始以参数，空格相隔，随之以值，行末回车。
  * 该行指定了协调员或参与者在运行之前的各项必要信息，具体如下：
  * **三个有效参数**：
    *  `mode` 运行模式：协调员 or 参与者。
      * 值仅为 `coordinator` / `participant`。 
      * 必须写在配置文件（除去注释行）的首行。
    *  `coordinator_info` 协调员信息
      * 明确协调员监听的网络地址，其值包括IP地址与端口号，`:` 冒号相隔。
      * 协调员将通过网络与客户端、参与者相互通信。
      * 因协调员仅能有一个，所以无论协调员还是参与者的配置文件，本参数行也仅能有一个。
    *  `participant_info` 参与者信息
      *  明确参与者监听的网络地址，其值包括IP地址与端口号，`:` 冒号相隔。
      * 参与者需通过网络与协调员取得通信，且不能直接与客户端相互通信。
      * 参与者的配置文件：仅能存在一行参与者信息，明确本参与者的网络地址。
      * 协调员的配置文件：存在多行参与者信息，因为协调员需要知道所有参与者的网络地址。

【例】协调员的配置文件

```
!
! Coordinator configuration
!      2020/05/07 11:25:33
!
! The argument name and value are separated by whitespace in the configuration file.
!
! Mode of process, coordinator OR participant
mode coordinator
!
! The address and port the coordinator process is listening on.
! Note that the address and port are separated by character ':'. 
coordinator_info 127.0.0.1:8001
!
! Address and port information of all participants. 
! Three lines specifies three participants' addresses.
participant_info 127.0.0.1:8002 
participant_info 127.0.0.1:8003 
participant_info 127.0.0.1:8004
```

【例】协调员的配置文件

```
!
! Participant configuration
!      2020/05/07 11:25:33
!
! The argument name and value are separated by whitespace in the configuration file.
!
! Mode of process, coordinator OR participant
mode participant
!
! The address and port the participant process is listening on.
participant_info 127.0.0.1:8002
!
! The address and port the coordinator process is listening on.
coordinator_info 127.0.0.1:8001
```

### 3.5 Implementation requirements 实现要求

#### 3.5.1 Basic version 初级版本

* 完成  `section 3.1-3.4` 所述内容。
* 整个程序需正确接收和执行KV指令，并返回相应结果。
* 协调员程序
  * 协调者之工作仅接收、处理、回复客户端提交的KV命令。
  * **协调者进程可能会被中止，并随时多次重启。**因此协调者不能存储任何数据库数据。
  * 协调者进程被中止时，则不需要给客户端命令任何返信。客户端会重发其KV命令，直到获得协调员的成功响应。
  * 协调者进程不会记住任何历史记录（配置文件的信息除外），因此它在重启后将所有命令作为新命令处理。
* 参与者程序
  * 初级版本中，使**参与者不发生任何错误**，但真实的网络仍可能丢包，可用TCP处理。
  * 初级版本中，至少存在**三个及以上**的参与者。

#### 3.5.2 Advanced version 高级版本（较之初级有不同者，加粗标出）

* 完成  `section 3.1-3.4` 所述内容。
* 整个程序需正确接收和执行KV指令，并返回相应结果。

* 协调员程序
  * 协调者之工作仅接收、处理、回复客户端提交的KV命令。
  * 协调者进程可能会被中止，并随时多次重启。因此协调者不能存储任何数据库数据。
  * 协调者进程被中止时，则不需要给客户端命令任何返信。客户端会重发其KV命令，直到获得协调员的成功响应。
  * 协调者进程不会记住任何历史记录（配置文件的信息除外），因此它在重启后将所有命令作为新命令处理，**并重测全员之生存与否**。
  * **协调者可以周期性地发送心跳检测（Heartbeat messages）来检测参与者出错与否。参与者一旦死亡，协调员应能将其从系统中删除，并将指令交予剩余参与者处理。**
  * **若全员死亡，协调员将一直返回 ERROR 给客户端。**
* 参与者程序
  * **高级版本中，参与者可能会出错，真实网络也可能出错。然而，这两类错误是一次性的，也即，已发生错误不会再次发生。**
  * 高级版本中，至少存在三个及以上的参与者。

* **注意：要发表 Demo3 的小组至少需完成高级版本。**

#### 3.5.3 Extreme version 极限版本（较之高级有不同者，加粗标出）

* 完成  `section 3.1-3.4` 所述内容。
* 整个程序需正确接收和执行KV指令，并返回相应结果。

* 协调员程序
  * 协调者之工作仅接收、处理、回复客户端提交的KV命令。
  * 协调者进程可能会被中止，并随时多次重启。因此协调者不能存储任何数据库数据。
  * 协调者进程被中止时，则不需要给客户端命令任何返信。客户端会重发其KV命令，直到获得协调员的成功响应。
  * 协调者进程不会记住任何历史记录（配置文件的信息除外），因此它在重启后将所有命令作为新命令处理，**并重测全员之生存与否**。
  * **协调者可以检测参与者出错及其重生。**
    * **参与者一旦死亡，协调员应能将其从系统中删除**
    * **参与者一旦重生，协调员应能将其注册进入系统**
  * 若全员死亡，协调员将一直返回 ERROR 给客户端。
* 参与者程序
  * 极限版本中，至少存在三个及以上的参与者。
  * 极限版本中，参与者可能会出错，真实网络也可能出错。**这两类错误可能是永久的 / 暂时的。也即，所有错误能随时卷土重来。**
  * **注意：为保证一致性，参与者重生后，应能从最近的参与者处复制KV库。教师组不会提供任何复制协议，且鼓励自行设计协议。**
  * **例如，假设两参与者A、B，A先出错，A重生后B出错。此过程中，客户端会持续发送KV指令，而A必须在重生后同步B的数据，否则在B出错后A就不能正常处理客户端的请求。**
* **课程团队会随机使参与者故障，并使其恢复。为确保重生时成功复制别者数据库，测试时的恢复过程中，会给10秒钟不会发生任何错误，此时协调员需要及时且准确复制数据到重生的参与者。同时，测试会保证至少一个正工作中的参与者，以便协调员能在故障恢复期间接收、处理、回复客户端的KV命令。**
  
* **注意：要发表 Demo4 的小组至少需完成极限版本。**

#### 3.5.6 Ultimate version 终极版本（与前三者均不同）

* 由于协调者可能会故障，系统应在**协调员故障时仍能处理客户端的请求。**
* 2PC 协议将不适用于本版本，但可以尝试更高级的协议来处理本版本关于协调的问题。
* 可以实现多个KV库服务器，每个服务器均能接收、处理、回复客户端的请求。
* 客户端预置了所有服务器的地址，并会随机发送KV命令。
* 为保证一致性，原则上有一总服务器充当协调员角色，来处理所有客户端的请求，并备份好数据。所有服务器接收到的请求将被重定向到总服务器处。
* 已验证的高级协议可以帮助保持数据库的一致性。
* [Raft](https://raft.github.io/) 是一个对此极佳的高级协议。课程团队不会教学此种协议。小组需要自行阅读其相关论文，并依此实现本版本的KV库服务器。（网络上有很多开源 Raft 的实现可以借鉴）

* 当然，能使用其它高级协议，或自行设计协议，都是最棒的。
* **[注意]** 本版本十分困难，所以这只是一个挑战，非强制性任务。**Have fun！**



## 4. Lab submission 实验提交

* 所有代码文件置于  `Lab3` 文件夹内，并编写 `Makefile`，以便课程团队测试时直接编译。
* 编译后的可运行二进制文件，名为 `kvstore2pcsystem`，并位于路径 `./Lab3/`。
* 谨遵上旨，以便自动化测试。

* **小组可以使用任意可获取的代码、库到本次实验中。请上网搜索。**
* **[注意] 不能抄袭它组代码。**
* **[注意] 本次实验不对性能测试报告作硬性要求。Enjoy the lab :)**
* **[注意] 递交实验时，谨遵 [`实验总述 翻译.md`](../实验总述 翻译.md) 指导。**

  **⚠  DDL：2020年5月27日 上午10点整**



## 5. Grading standards 得分标准

* **13 分 |** 完成初级版本
* **21 分 |** 完成高级版本
* **24 分 |** 完成极限版本
* **25 分 |** 完成终极版本

  **⚠  满则盈，缺稍殆。历史至上。**

